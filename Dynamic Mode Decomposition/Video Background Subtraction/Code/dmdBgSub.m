
%this function applies DMD algorithm to subtract the background low rank
%information from a video and captures the moving objects 

%define the function and its parameters
%rank: is the number of DMD eignevalues truncated
%cutoff: is the DMD spectrum of frequencies asscoiated to the background 
function [fgVid, bgVid] = dmdBgSub(filename, rank, cutoff)
%------------

%Video Processing
frames = read(VideoReader(filename)); %read the video
[lx,ly,~,n] = size(frames) %specify the number of pixels on x (lx) 
% and y (ly) axes. ALso, specify how many frames/snapshots there are in 
% the video assuming that the difference betwen them is delta t = 1

%create the viedo 3D matrix: (no of horizontal pixels) x (no of vertical
%pixels) x (no of snapshots)
X = zeros(lx*ly, n); %initiate
for i=1:n
    frame = double(im2gray(frames(:,:,:,i))); %convert each snapshot to grayscale
    X(:, i) = reshape(frame, lx*ly, 1); %reshape it to a vector
end
%------------

%DMD algorithm
%create DMD matrices
X1 = X(:, 1:end-1);
X2 = X(:, 2:end);

% SVD of original image matrix, with rank cutoff applied
[U, S, V] = svd(X1, 'econ');
U = U(:, 1:rank); %truncated left eigenvectors
V = V(:, 1:rank); %truncated right eigenvectors
S = S(1:rank, 1:rank); %truncated eigenvalues

% DMD calculations applying Koopman operator to generate dynamic modes
Ar = U'*X2*V/S; %Build Atilde and DMD modes: least square matrix/linear operator
[W, D] = eig(Ar); %eigen decomposition
Lambda = diag(D); %DMD eigenvalues spectra
omega = log(Lambda); %frequency
phi = X2*V/S*W; %DMD spatial modes 
% reconstruction of modes/function in time
% compute DMD solution
x1 = X(:,1); %t=0
x0 = phi\x1;
u_modes = zeros(rank,n);
for i = 1:n
    u_modes(:,i) =(x0.*exp(omega*i));
end
X_DMD = phi * u_modes; %the full solution of the linear model generated by DMD

% Reconstruct background using omega cutoff
modes = abs(omega)<cutoff; %extract all low rank frequencies
u_back = phi(:, modes)*u_modes(modes, :); %the DMD solution of the linear model for the bakground
%-----------

%plotting
% Plot calculated omega values in the complex plane
figure;
plot(real(omega), imag(omega),'ro','Linewidth',1)
hold on
plot(real(omega(2,:)),imag(omega(2,:)),'r*','Linewidth',2)
xlabel('$\mathrm{Re}(\omega)$','interpreter','latex')
ylabel('$\mathrm{Im}(\omega)$','interpreter','latex')
set(gca,'fontsize',14)
set(gca,'TickLabelInterpreter','latex')

% Specify which frames to preview
figure;
preview = [50, 100, 200];
% Write background and foreground images frame by frame
j = 1; %frames counter
fgVid = uint8(zeros(lx, ly, n)); %construct the foreground video
bgVid = uint8(zeros(lx, ly, n)); %construct the background video
for i=1:n %loop over the frames 
    backgroundvec = abs(u_back(:,i)); %take the 
    framevec = abs(X(:,i)); %calculate the real-valued (modulus of each element) background elements only
    foregroundvec = framevec-backgroundvec; %calculate the foreground video by subtracting the original viedo from the background
    % negInds = foregroundvec<0;
    % backgroundvec(negInds) = backgroundvec(negInds) - foregroundvec(negInds);
    foregroundvec = foregroundvec - min(foregroundvec); %subtracing the residual negative values which would not make sense in terms of having negative pixel intensities. 
    bg = uint8(reshape(backgroundvec, lx, ly)*255/max(backgroundvec)); %normalise the background
    fg = uint8(reshape(foregroundvec, lx, ly)*255/max(foregroundvec)); %normalise the foreground
    % Plot the original, FG, and BG of specified frames
    if ismember(i, preview)
        im = uint8(reshape(framevec, lx, ly)*255/max(framevec));
        subplot(length(preview),3,(j-1)*3+1), imshow(im), title(['Original Frame #',num2str(preview(j))]), drawnow;
        subplot(length(preview),3,(j-1)*3+2), imshow(bg), title('Background'), drawnow;
        subplot(length(preview),3,(j-1)*3+3), imshow(fg), title('Foreground'), drawnow;
        j=j+1;
    end
    bgVid(:, :, i)=bg;
    fgVid(:, :, i)=fg;
end
%-----------

end
